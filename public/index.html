<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distli Mesh BC - Blockchain Trading</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .trading-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .order-form {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        .order-form input, .order-form select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .order-book {
            font-family: monospace;
            font-size: 12px;
        }
        .order-book table {
            width: 100%;
            border-collapse: collapse;
        }
        .order-book th, .order-book td {
            padding: 4px 8px;
            text-align: right;
            border: 1px solid #eee;
        }
        .bid-row { background: #e8f5e8; }
        .ask-row { background: #ffeaea; }
        .trade-row { background: #e3f2fd; }
        .offline-row { background: #fff3cd; }
        .status {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat {
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            text-align: center;
        }
        .stat strong {
            display: block;
            font-size: 18px;
            color: #007bff;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        button.buy {
            background: #28a745;
        }
        button.buy:hover {
            background: #218838;
        }
        button.sell {
            background: #dc3545;
        }
        button.sell:hover {
            background: #c82333;
        }
        .refresh-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .refresh-btn:hover {
            background: #218838;
        }
        input[type="text"], select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
        .block {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px;
            margin: 10px 0;
        }
        .block-header {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .block-data {
            color: #666;
            font-size: 14px;
        }
        .peers {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .peer {
            background: #d4edda;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
        }
        .trading-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background: #e9ecef;
            border-radius: 4px;
            cursor: pointer;
        }
        .tab.active {
            background: #007bff;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .runtime-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            color: white;
            margin-left: 5px;
        }
        .runtime-rust { background: #CE422B; }
        .runtime-python { background: #3776AB; }
        .runtime-wasm { background: #654FF0; }
        .runtime-javascript { background: #F7DF1E; color: black; }

        /* Contract Editor Styles */
        .contract-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .contract-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
            transition: box-shadow 0.2s;
        }
        .contract-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .contract-card h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .btn-danger { background: #dc3545; color: white; }
        .btn:hover { opacity: 0.8; }
        .editor-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .editor-content {
            background-color: white;
            margin: 2% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 1000px;
            height: 85vh;
            overflow-y: auto;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover { color: black; }
        .code-editor {
            width: 100%;
            height: 400px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background: #f8f9fa;
            resize: vertical;
        }
        .execution-log {
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 15px;
            border-radius: 4px;
            height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 3px 6px;
            border-radius: 3px;
            border-left: 3px solid;
        }
        .log-success { border-color: #28a745; background: rgba(40, 167, 69, 0.1); }
        .log-error { border-color: #dc3545; background: rgba(220, 53, 69, 0.1); }
        .log-info { border-color: #17a2b8; background: rgba(23, 162, 184, 0.1); }
        .log-warning { border-color: #ffc107; background: rgba(255, 193, 7, 0.1); }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }
        .execution-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 5px;
        }
        .execution-active { background: #28a745; color: white; }
        .execution-idle { background: #6c757d; color: white; }
        .execution-error { background: #dc3545; color: white; }
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 768px) {
            .two-column {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <h1>Distli Mesh BC - Blockchain Trading</h1>
    
    <!-- Status and connection -->
    <div class="container">
        <div class="status">
            <div class="stat">
                <strong id="peer-count">0</strong>
                <div>Peers</div>
            </div>
            <div class="stat">
                <strong id="block-count">1</strong>
                <div>Blocks</div>
            </div>
            <div class="stat">
                <strong id="pending-count">0</strong>
                <div>Pending</div>
            </div>
            <div class="stat">
                <strong id="status">Disconnected</strong>
                <div>Status</div>
            </div>
            <div class="stat">
                <strong id="network-name">None</strong>
                <div>Network</div>
            </div>
        </div>
        
        <div style="margin-bottom: 15px;">
            <label>Server: </label>
            <input type="text" id="server-input" value="" placeholder="server-ip:3030" style="width: 150px;">
            <label style="margin-left: 15px;">Network: </label>
            <select id="network-select" style="width: 180px;">
                <option value="">Select network...</option>
            </select>
            <input type="text" id="network-input" value="" placeholder="or enter new" style="width: 120px; margin-left: 5px;">
            <button id="refresh-networks-btn" class="refresh-btn" style="margin-left: 5px;" title="Refresh network list">↻</button>
        </div>
        
        <div style="margin-bottom: 15px;">
            <button id="connect-btn">Connect</button>
            <button id="join-network-btn" disabled>Join Network</button>
            <button id="discover-btn" disabled>Discover Peers</button>
            <button id="connect-all-btn" disabled>Connect All</button>
            <button id="sync-blockchain-btn" disabled onclick="testBlockchainSync()">Sync to Enterprise</button>
        </div>
    </div>

    <!-- Trading Tabs -->
    <div class="container">
        <div class="trading-tabs">
            <div class="tab active" data-tab="messaging">Messaging</div>
            <div class="tab" data-tab="trading">Trading</div>
            <div class="tab" data-tab="orderbook">Order Book</div>
            <div class="tab" data-tab="contracts">Smart Contracts</div>
            <div class="tab" data-tab="contract-editor">Contract Editor</div>
        </div>

        <!-- Messaging Tab -->
        <div class="tab-content active" id="messaging-tab">
            <h3>Send Message</h3>
            <input type="text" id="tx-input" placeholder="Enter message">
            <button id="send-btn" disabled>Send Message</button>
            <button id="mine-btn" disabled>Mine Block</button>
        </div>

        <!-- Trading Tab -->
        <div class="tab-content" id="trading-tab">
            <div class="trading-grid">
                <div>
                    <div class="order-form">
                        <h4>Buy Order</h4>
                        <select id="buy-asset">
                            <option value="BTC">BTC</option>
                            <option value="ETH">ETH</option>
                            <option value="ADA">ADA</option>
                        </select>
                        <input type="number" id="buy-quantity" placeholder="Quantity" step="0.001" min="0">
                        <input type="number" id="buy-price" placeholder="Price" step="0.01" min="0">
                        <button class="buy" onclick="placeBuyOrder()">Place Buy Order</button>
                    </div>
                </div>
                
                <div>
                    <div class="order-form">
                        <h4>Sell Order</h4>
                        <select id="sell-asset">
                            <option value="BTC">BTC</option>
                            <option value="ETH">ETH</option>
                            <option value="ADA">ADA</option>
                        </select>
                        <input type="number" id="sell-quantity" placeholder="Quantity" step="0.001" min="0">
                        <input type="number" id="sell-price" placeholder="Price" step="0.01" min="0">
                        <button class="sell" onclick="placeSellOrder()">Place Sell Order</button>
                    </div>
                </div>
            </div>

            <h4>Smart Contract Actions</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <button onclick="callPythonPredictor()" style="background: #3776AB;">Python ML Predict</button>
                <button onclick="callWasmDeFi()" style="background: #654FF0;">WASM DeFi Pool</button>
                <button onclick="callJavaScriptAnalytics()" style="background: #F7DF1E; color: black;">JS Analytics</button>
            </div>

            <h4>Recent Trades</h4>
            <div id="recent-trades" class="order-book">
                <table>
                    <thead>
                        <tr><th>Time</th><th>Asset</th><th>Quantity</th><th>Price</th><th>Buyer</th><th>Seller</th></tr>
                    </thead>
                    <tbody id="trades-tbody">
                        <tr><td colspan="6">No trades yet - place some orders</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Order Book Tab -->
        <div class="tab-content" id="orderbook-tab">
            <div style="margin-bottom: 15px;">
                <label>Filter by asset: </label>
                <select id="orderbook-asset">
                    <option value="">All Assets</option>
                    <option value="BTC">BTC</option>
                    <option value="ETH">ETH</option>
                    <option value="ADA">ADA</option>
                </select>
                <button onclick="updateOrderBookFromContract()">Refresh</button>
            </div>

            <div class="trading-grid">
                <div>
                    <h4>Buy Orders (Bids)</h4>
                    <div class="order-book">
                        <table>
                            <thead>
                                <tr><th>Price</th><th>Quantity</th><th>Trader</th><th>Action</th></tr>
                            </thead>
                            <tbody id="bids-tbody">
                                <tr><td colspan="4">No buy orders</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div>
                    <h4>Sell Orders (Asks)</h4>
                    <div class="order-book">
                        <table>
                            <thead>
                                <tr><th>Price</th><th>Quantity</th><th>Trader</th><th>Action</th></tr>
                            </thead>
                            <tbody id="asks-tbody">
                                <tr><td colspan="4">No sell orders</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Smart Contracts Tab -->
        <div class="tab-content" id="contracts-tab">
            <h4>Multi-Language Smart Contracts</h4>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="order-form">
                    <h5>Rust Trading Contract</h5>
                    <p>High-performance order matching and trade execution</p>
                    <button onclick="showContractState('trading_contract')" style="background: #CE422B;">View State</button>
                </div>
                
                <div class="order-form">
                    <h5>Python ML Predictor</h5>
                    <p>Machine learning price prediction and analysis</p>
                    <button onclick="showContractState('ml_predictor')" style="background: #3776AB;">View State</button>
                    <button onclick="callPythonPredictor()" style="background: #3776AB; margin-left: 5px;">Predict</button>
                </div>
                
                <div class="order-form">
                    <h5>WASM DeFi Protocol</h5>
                    <p>Liquidity pools and decentralized exchange</p>
                    <button onclick="showContractState('defi_pool')" style="background: #654FF0;">View State</button>
                    <button onclick="callWasmDeFi()" style="background: #654FF0; margin-left: 5px;">Add Liquidity</button>
                </div>
                
                <div class="order-form">
                    <h5>JavaScript Analytics</h5>
                    <p>Real-time market analysis and indicators</p>
                    <button onclick="showContractState('js_analytics')" style="background: #F7DF1E; color: black;">View State</button>
                    <button onclick="callJavaScriptAnalytics()" style="background: #F7DF1E; color: black; margin-left: 5px;">Analyze</button>
                </div>
            </div>
            
            <div id="contract-state-display" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 20px; display: none;">
                <h5>Contract State</h5>
                <pre id="contract-state-content" style="background: white; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 12px;"></pre>
            </div>
        </div>

        <!-- Contract Editor Tab -->
        <div class="tab-content" id="contract-editor-tab">
            <!-- Contract Management -->
            <h3>Contract Management</h3>
            <div style="margin-bottom: 20px;">
                <button class="btn btn-success" onclick="showNewContractDialog()">
                    Add New Contract
                </button>
                <button class="btn btn-primary" onclick="refreshContracts()">
                    Refresh
                </button>
                <button class="btn btn-warning" onclick="exportContracts()">
                    Export All
                </button>
            </div>
            
            <div id="contract-list" class="contract-list">
                <!-- Contracts will be populated here -->
            </div>

            <!-- Real-time Execution Monitor -->
            <h3>Contract Execution Monitor</h3>
            <div style="margin-bottom: 15px;">
                <button id="monitor-toggle" class="btn btn-success" onclick="toggleExecutionMonitor()">
                    Start Monitoring
                </button>
                <button class="btn btn-secondary" onclick="clearExecutionLog()">
                    Clear Log
                </button>
                <label style="margin-left: 20px;">
                    <input type="checkbox" id="auto-scroll" checked> Auto-scroll
                </label>
            </div>
            
            <div id="execution-log" class="execution-log">
                <div class="log-entry log-info">Contract execution monitor ready. Click "Start Monitoring" to begin tracking contract executions.</div>
            </div>
        </div>
    </div>

    <!-- Connected Peers -->
    <div class="container">
        <h3>Connected Peers</h3>
        <div class="peers" id="peers-list">
            <div>No peers connected</div>
        </div>
    </div>

    <!-- Blockchain -->
    <div class="container">
        <h3>Blockchain</h3>
        <div id="pending-transactions" style="margin-bottom: 15px;"></div>
        <div id="blockchain"></div>
    </div>

    <!-- Activity Log -->
    <div class="container">
        <h3>Activity Log</h3>
        <div class="log" id="log"></div>
    </div>

    <!-- Contract Editor Modal -->
    <div id="contract-editor-modal" class="editor-modal">
        <div class="editor-content">
            <span class="close" onclick="closeContractEditor()">&times;</span>
            <h3 id="editor-title">Edit Contract</h3>
            
            <div class="form-group">
                <label>Contract Name:</label>
                <input type="text" id="edit-contract-name">
            </div>
            
            <div class="two-column">
                <div class="form-group">
                    <label>Contract ID:</label>
                    <input type="text" id="edit-contract-id" readonly>
                </div>
                <div class="form-group">
                    <label>Programming Style:</label>
                    <select id="edit-contract-runtime">
                        <option value="javascript">JavaScript</option>
                        <option value="rust-style">Rust-style Syntax</option>
                        <option value="python-style">Python-style Syntax</option>
                        <option value="functional">Functional Style</option>
                    </select>
                    <small style="color: #666;">All contracts execute as JavaScript</small>
                </div>
            </div>
            
            <div class="form-group">
                <label>Contract Code:</label>
                <textarea id="contract-code" class="code-editor" placeholder="Enter your contract code here..."></textarea>
            </div>
            
            <div style="margin-bottom: 15px;">
                <button class="btn btn-primary" onclick="saveContract()">Save Contract</button>
                <button class="btn btn-success" onclick="deployContract()">Deploy & Test</button>
                <button class="btn btn-warning" onclick="testContract()">Quick Test</button>
                <button class="btn btn-secondary" onclick="closeContractEditor()">Cancel</button>
            </div>
            
            <!-- Quick Test Section -->
            <div id="quick-test-section" style="border-top: 1px solid #ddd; padding-top: 15px;">
                <h4>Quick Test</h4>
                <div class="two-column">
                    <div class="form-group">
                        <label>Function to Call:</label>
                        <select id="test-function">
                            <option value="">Select function...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Parameters (JSON):</label>
                        <input type="text" id="test-params" placeholder='{"param": "value"}'>
                    </div>
                </div>
                <div id="test-result" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px; display: none;"></div>
            </div>
        </div>
    </div>

    <!-- New Contract Modal -->
    <div id="new-contract-modal" class="editor-modal">
        <div class="editor-content">
            <span class="close" onclick="closeNewContractDialog()">&times;</span>
            <h3>Create New Contract</h3>
            
            <div class="two-column">
                <div class="form-group">
                    <label>Contract ID:</label>
                    <input type="text" id="new-contract-id" placeholder="my_contract">
                </div>
                <div class="form-group">
                    <label>Contract Name:</label>
                    <input type="text" id="new-contract-name" placeholder="My Contract">
                </div>
            </div>
            
            <div class="form-group">
                <label>Programming Style:</label>
                <select id="new-contract-runtime">
                    <option value="javascript">JavaScript</option>
                    <option value="rust-style">Rust-style Syntax</option>
                    <option value="python-style">Python-style Syntax</option>
                    <option value="functional">Functional Style</option>
                </select>
                <small style="color: #666;">All contracts run as JavaScript, but you can use different coding styles</small>
            </div>
            
            <div class="form-group">
                <label>Template:</label>
                <select id="contract-template" onchange="loadContractTemplate()">
                    <option value="">Empty Contract</option>
                    <option value="counter">Simple Counter</option>
                    <option value="counter-rust">Counter (Rust-style)</option>
                    <option value="counter-python">Counter (Python-style)</option>
                    <option value="voting">Voting System</option>
                    <option value="token">Token Contract</option>
                    <option value="marketplace">Marketplace</option>
                </select>
            </div>
            
            <div class="form-group">
                <label>Contract Code:</label>
                <textarea id="new-contract-code" class="code-editor" placeholder="Enter your contract code..."></textarea>
            </div>
            
            <div>
                <button class="btn btn-success" onclick="createNewContract()">Create Contract</button>
                <button class="btn btn-secondary" onclick="closeNewContractDialog()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced blockchain class - WITH SMART CONTRACTS
        class SmartBlockchain {
            constructor() {
                this.chain = [this.createGenesis()];
                this.pending = [];
                this.contract_vm = new ContractVM();
                this.initializeTradingContract();
            }
            
            createGenesis() {
                return {
                    id: 0,
                    hash: "000genesis",
                    prev_hash: "0",
                    timestamp: Date.now(),
                    data: "Genesis Block",
                    nonce: 0,
                    transactions: []
                };
            }
            
            initializeTradingContract() {
                // Initialize multi-language contract VM
                this.contract_vm = new ContractVM();
                log('Multi-language contract system initialized');
            }
            
            // Message transactions
            addMessage(data, sender = 'anonymous') {
                const tx = {
                    type: 'message',
                    id: 'msg_' + Date.now(),
                    data: data,
                    timestamp: Date.now(),
                    sender: sender
                };
                this.pending.push(tx);
                this.saveToStorage();
                return tx;
            }
            
            // Smart contract calls
            call_contract(call, sender) {
                const tx = {
                    type: 'contract_call',
                    id: 'call_' + Date.now(),
                    call: call,
                    result: null,
                    timestamp: Date.now(),
                    sender: sender
                };
                
                // Execute the contract call immediately
                try {
                    const result = this.contract_vm.call_contract(call);
                    tx.result = result;
                    
                    if (result.success) {
                        log(`Contract call successful: ${call.function}`);
                    } else {
                        log(`Contract call failed: ${result.error}`);
                    }
                } catch (error) {
                    log(`Contract execution error: ${error.message}`);
                    tx.result = {
                        success: false,
                        error: error.message,
                        gas_used: 0
                    };
                }
                
                this.pending.push(tx);
                this.saveToStorage();
                return tx;
            }
            
            // Get trading data from smart contract
            get_order_book(asset = null) {
                try {
                    return this.contract_vm.get_order_book(asset);
                } catch (error) {
                    log('Error getting order book: ' + error.message);
                    return { bids: [], asks: [] };
                }
            }
            
            get_recent_trades(asset = null, limit = 10) {
                try {
                    return this.contract_vm.get_recent_trades(asset, limit);
                } catch (error) {
                    log('Error getting recent trades: ' + error.message);
                    return { trades: [] };
                }
            }
            
            mineBlock() {
                if (this.pending.length === 0) return null;
                
                const lastBlock = this.chain[this.chain.length - 1];
                const transactions = [...this.pending];
                
                // Create summary for display
                const data = transactions.map(tx => {
                    if (tx.type === 'message') {
                        return `${tx.sender}: ${tx.data}`;
                    } else if (tx.type === 'contract_call') {
                        const asset = tx.call.params.asset || 'unknown';
                        const qty = tx.call.params.quantity || '';
                        const price = tx.call.params.price || '';
                        return `${tx.sender}: ${tx.call.function}(${asset} ${qty}@${price})`;
                    }
                    return `${tx.sender}: ${tx.type}`;
                }).join(", ");
                
                const block = {
                    id: lastBlock.id + 1,
                    hash: "000" + Date.now().toString(),
                    prev_hash: lastBlock.hash,
                    timestamp: Date.now(),
                    data: data,
                    nonce: Math.floor(Math.random() * 1000000),
                    transactions: transactions
                };
                
                this.chain.push(block);
                this.pending = [];
                this.saveToStorage();
                
                // Send blockchain update to tracker for enterprise sync
                this.sendBlockchainUpdate();
                
                return block;
            }
            
            // NEW: Send blockchain state to tracker
            sendBlockchainUpdate() {
                if (!window.mesh || !window.mesh.connected || !window.mesh.currentNetwork) {
                    log('Cannot send blockchain update - not connected to network');
                    return;
                }
                
                // Get recent blocks (last 5 blocks, excluding genesis)
                const recentBlocks = this.chain.slice(1).slice(-5).map(block => ({
                    block_id: block.id,
                    block_hash: block.hash,
                    transactions: block.transactions.map(tx => {
                        if (tx.type === 'message') {
                            return tx.data;
                        } else if (tx.type === 'contract_call') {
                            return `${tx.call.function}: ${JSON.stringify(tx.call.params)}`;
                        }
                        return tx.type;
                    }),
                    timestamp: Math.floor(block.timestamp / 1000), // Convert to seconds
                    previous_hash: block.prev_hash
                }));
                
                if (recentBlocks.length === 0) {
                    log('No blocks to send to enterprise BC');
                    return;
                }
                
                const message = {
                    type: 'blockchain_update',
                    network_id: window.mesh.currentNetwork,
                    peer_id: getUserId(),
                    new_blocks: recentBlocks,
                    timestamp: Math.floor(Date.now() / 1000)
                };
                
                // Send to tracker via WebSocket
                window.mesh.send(message);
                
                log(`Sent blockchain update: ${recentBlocks.length} blocks to tracker`);
            }
            
            addBlock(block) {
                const lastBlock = this.chain[this.chain.length - 1];
                if (block.id === lastBlock.id + 1 && block.prev_hash === lastBlock.hash) {
                    // Process contract transactions when receiving blocks from peers
                    for (const tx of block.transactions) {
                        if (tx.type === 'contract_call' && tx.result) {
                            // Re-apply the state changes from the transaction result
                            this.contract_vm.apply_state_changes(tx.call.contract_id, tx.result.state_changes);
                        }
                    }
                    
                    this.chain.push(block);
                    this.saveToStorage();
                    
                    // Send blockchain update after adding block from peer
                    setTimeout(() => {
                        this.sendBlockchainUpdate();
                    }, 100);
                    
                    return true;
                }
                return false;
            }
            
            saveToStorage() {
                try {
                    const data = {
                        chain: this.chain,
                        pending: this.pending,
                        contract_state: this.contract_vm.get_all_state(),
                        lastSaved: Date.now()
                    };
                    const networkId = (window.mesh && window.mesh.currentNetwork) || 'default';
                    localStorage.setItem(`blockchain_${networkId}`, JSON.stringify(data));
                } catch (error) {
                    log(`Failed to save blockchain: ${error.message}`);
                }
            }
            
            loadFromStorage() {
                try {
                    const networkId = (window.mesh && window.mesh.currentNetwork) || 'default';
                    const stored = localStorage.getItem(`blockchain_${networkId}`);
                    if (stored) {
                        const data = JSON.parse(stored);
                        if (data && data.chain && data.chain.length > 0) {
                            this.chain = data.chain;
                            this.pending = data.pending || [];
                            
                            // Restore contract state
                            if (data.contract_state) {
                                this.contract_vm.restore_state(data.contract_state);
                            } else {
                                this.initializeTradingContract();
                            }
                            return true;
                        }
                    }
                    this.initializeTradingContract();
                    return false;
                } catch (error) {
                    log(`Failed to load blockchain: ${error.message}`);
                    this.initializeTradingContract();
                    return false;
                }
            }
        }

        // Enhanced Contract VM for multi-language support
        class ContractVM {
            constructor() {
                this.contracts = new Map();
                this.initializeMultiLanguageContracts();
            }
            
            initializeMultiLanguageContracts() {
                // Deploy trading contract (Rust)
                const tradingContract = {
                    id: "trading_contract",
                    name: "Trading Contract",
                    runtime: "rust",
                    code: "trading",
                    state: {
                        orderBook: { bids: [], asks: [] },
                        trades: [],
                        nextOrderId: 1
                    },
                    owner: "system",
                    created_at: Date.now()
                };
                
                // Deploy Python ML contract
                const pythonContract = {
                    id: "ml_predictor",
                    name: "ML Price Predictor",
                    runtime: "python",
                    code: "ml_prediction",
                    state: {
                        priceHistory: {},
                        predictions: [],
                        models: {}
                    },
                    owner: "system",
                    created_at: Date.now()
                };
                
                // Deploy WASM DeFi contract
                const wasmContract = {
                    id: "defi_pool",
                    name: "DeFi Liquidity Pool",
                    runtime: "wasm",
                    code: "defi_protocol",
                    state: {
                        liquidity: {},
                        totalShares: 0,
                        feeRate: 0.003
                    },
                    owner: "system",
                    created_at: Date.now()
                };
                
                // Deploy JavaScript Analytics contract
                const jsContract = {
                    id: "js_analytics",
                    name: "Market Analytics",
                    runtime: "javascript", 
                    code: "market_analytics",
                    state: {
                        marketData: {},
                        indicators: {},
                        alerts: []
                    },
                    owner: "system",
                    created_at: Date.now()
                };
                
                this.contracts.set("trading_contract", tradingContract);
                this.contracts.set("ml_predictor", pythonContract);
                this.contracts.set("defi_pool", wasmContract);
                this.contracts.set("js_analytics", jsContract);
                
                log('Multi-language contracts deployed: Rust, Python, WASM, JavaScript');
            }
            
            deploy_contract(contract) {
                this.contracts.set(contract.id, contract);
                return contract.id;
            }
            
            call_contract(call) {
                const contract = this.contracts.get(call.contract_id);
                if (!contract) {
                    throw new Error("Contract not found");
                }
                
                // Route to appropriate runtime
                switch (contract.runtime) {
                    case "rust":
                    case "trading":
                        return this.execute_rust_contract(contract, call);
                    case "python":
                        return this.execute_python_contract(contract, call);
                    case "wasm":
                        return this.execute_wasm_contract(contract, call);
                    case "javascript":
                        return this.execute_javascript_contract(contract, call);
                    default:
                        throw new Error("Unknown runtime: " + contract.runtime);
                }
            }
            
            execute_rust_contract(contract, call) {
                if (contract.code === "trading") {
                    return this.execute_trading_function(contract.state, call);
                }
                throw new Error("Unknown Rust contract");
            }
            
            execute_python_contract(contract, call) {
                const state = contract.state;
                
                switch (call.function) {
                    case "predict_price":
                        return this.python_predict_price(state, call.params, call.caller);
                    case "train_model":
                        return this.python_train_model(state, call.params, call.caller);
                    default:
                        throw new Error("Unknown Python function: " + call.function);
                }
            }
            
            execute_wasm_contract(contract, call) {
                const state = contract.state;
                
                switch (call.function) {
                    case "add_liquidity":
                        return this.wasm_add_liquidity(state, call.params, call.caller);
                    case "swap":
                        return this.wasm_swap(state, call.params, call.caller);
                    case "get_pool_info":
                        return this.wasm_get_pool_info(state, call.params, call.caller);
                    default:
                        throw new Error("Unknown WASM function: " + call.function);
                }
            }
            
            execute_javascript_contract(contract, call) {
                const state = contract.state;
                
                switch (call.function) {
                    case "analyze_market":
                        return this.js_analyze_market(state, call.params, call.caller);
                    case "calculate_indicators":
                        return this.js_calculate_indicators(state, call.params, call.caller);
                    default:
                        throw new Error("Unknown JavaScript function: " + call.function);
                }
            }
            
            // Python ML functions
            python_predict_price(state, params, caller) {
                const asset = params.asset || "BTC";
                
                // Simple moving average prediction
                if (!state.priceHistory[asset]) {
                    state.priceHistory[asset] = [50, 52, 48, 55, 53, 51, 49, 54, 56, 52];
                }
                
                const prices = state.priceHistory[asset];
                const recent = prices.slice(-5);
                const avg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const trend = (recent[recent.length - 1] - recent[0]) / recent[0];
                
                const prediction = {
                    asset: asset,
                    current_price: prices[prices.length - 1],
                    predicted_price: Math.round(avg * (1 + trend * 0.1) * 100) / 100,
                    confidence: 0.6 + Math.random() * 0.3,
                    trend: trend > 0 ? "bullish" : "bearish",
                    timestamp: Date.now()
                };
                
                state.predictions.push(prediction);
                
                return {
                    success: true,
                    result: prediction,
                    gas_used: 2000,
                    state_changes: state
                };
            }
            
            python_train_model(state, params, caller) {
                const asset = params.asset || "BTC";
                const data = params.training_data || [];
                
                // Simulate model training
                state.models[asset] = {
                    trained_at: Date.now(),
                    accuracy: 0.75 + Math.random() * 0.2,
                    features: ["price", "volume", "volatility"],
                    type: "lstm_neural_network"
                };
                
                return {
                    success: true,
                    result: {
                        message: `Model trained for ${asset}`,
                        accuracy: state.models[asset].accuracy,
                        model_id: `${asset}_model_${Date.now()}`
                    },
                    gas_used: 5000,
                    state_changes: state
                };
            }
            
            // WASM DeFi functions
            wasm_add_liquidity(state, params, caller) {
                const assetA = params.asset_a || "BTC";
                const assetB = params.asset_b || "ETH";
                const amountA = params.amount_a || 0;
                const amountB = params.amount_b || 0;
                
                const poolKey = `${assetA}_${assetB}`;
                
                if (!state.liquidity[poolKey]) {
                    state.liquidity[poolKey] = { assetA: 0, assetB: 0, totalShares: 0 };
                }
                
                const pool = state.liquidity[poolKey];
                const shares = Math.sqrt(amountA * amountB);
                
                pool.assetA += amountA;
                pool.assetB += amountB;
                pool.totalShares += shares;
                
                return {
                    success: true,
                    result: {
                        pool: poolKey,
                        shares_minted: Math.round(shares * 100) / 100,
                        total_liquidity: {
                            [assetA]: pool.assetA,
                            [assetB]: pool.assetB
                        }
                    },
                    gas_used: 3000,
                    state_changes: state
                };
            }
            
            wasm_swap(state, params, caller) {
                const fromAsset = params.from_asset;
                const toAsset = params.to_asset;
                const amount = params.amount || 0;
                
                const poolKey = `${fromAsset}_${toAsset}`;
                const pool = state.liquidity[poolKey];
                
                if (!pool) {
                    return {
                        success: false,
                        error: "Pool not found",
                        gas_used: 1000
                    };
                }
                
                // Simple constant product formula
                const outputAmount = (pool.assetB * amount) / (pool.assetA + amount);
                const feeAmount = outputAmount * state.feeRate;
                const finalOutput = outputAmount - feeAmount;
                
                pool.assetA += amount;
                pool.assetB -= finalOutput;
                
                return {
                    success: true,
                    result: {
                        input_amount: amount,
                        output_amount: Math.round(finalOutput * 100) / 100,
                        fee_amount: Math.round(feeAmount * 100) / 100,
                        price_impact: Math.round((amount / pool.assetA) * 100 * 100) / 100
                    },
                    gas_used: 2500,
                    state_changes: state
                };
            }
            
            wasm_get_pool_info(state, params, caller) {
                const assetA = params.asset_a || "BTC";
                const assetB = params.asset_b || "ETH";
                const poolKey = `${assetA}_${assetB}`;
                const pool = state.liquidity[poolKey];
                
                if (!pool) {
                    return {
                        success: false,
                        error: "Pool not found",
                        gas_used: 500
                    };
                }
                
                return {
                    success: true,
                    result: {
                        pool: poolKey,
                        liquidity: pool,
                        current_price: pool.assetB / pool.assetA,
                        fee_rate: state.feeRate
                    },
                    gas_used: 800,
                    state_changes: null
                };
            }
            
            // JavaScript Analytics functions
            js_analyze_market(state, params, caller) {
                const asset = params.asset || "BTC";
                
                // Get recent trades for analysis
                const tradingContract = this.contracts.get("trading_contract");
                const trades = tradingContract.state.trades || [];
                const assetTrades = trades.filter(t => t.asset === asset).slice(-10);
                
                if (assetTrades.length === 0) {
                    return {
                        success: true,
                        result: {
                            asset: asset,
                            volume: 0,
                            price_change: 0,
                            volatility: 0,
                            recommendation: "insufficient_data"
                        },
                        gas_used: 1500,
                        state_changes: state
                    };
                }
                
                const prices = assetTrades.map(t => t.price);
                const volumes = assetTrades.map(t => t.quantity);
                
                const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
                const totalVolume = volumes.reduce((a, b) => a + b, 0);
                const priceChange = ((prices[prices.length - 1] - prices[0]) / prices[0]) * 100;
                
                // Simple volatility calculation
                const variance = prices.reduce((acc, price) => acc + Math.pow(price - avgPrice, 2), 0) / prices.length;
                const volatility = Math.sqrt(variance) / avgPrice;
                
                const analysis = {
                    asset: asset,
                    volume_24h: Math.round(totalVolume * 100) / 100,
                    price_change_pct: Math.round(priceChange * 100) / 100,
                    volatility: Math.round(volatility * 100) / 100,
                    avg_price: Math.round(avgPrice * 100) / 100,
                    recommendation: priceChange > 5 ? "buy" : priceChange < -5 ? "sell" : "hold",
                    analyzed_at: Date.now()
                };
                
                state.marketData[asset] = analysis;
                
                return {
                    success: true,
                    result: analysis,
                    gas_used: 1800,
                    state_changes: state
                };
            }
            
            js_calculate_indicators(state, params, caller) {
                const asset = params.asset || "BTC";
                
                // Mock technical indicators
                const indicators = {
                    rsi: 45 + Math.random() * 20,
                    macd: (Math.random() - 0.5) * 10,
                    bollinger_upper: 55000 + Math.random() * 5000,
                    bollinger_lower: 45000 + Math.random() * 5000,
                    sma_20: 50000 + Math.random() * 10000,
                    ema_12: 51000 + Math.random() * 8000,
                    volume_indicator: Math.random() > 0.5 ? "high" : "normal"
                };
                
                state.indicators[asset] = {
                    ...indicators,
                    calculated_at: Date.now()
                };
                
                return {
                    success: true,
                    result: {
                        asset: asset,
                        indicators: indicators,
                        signals: {
                            buy: indicators.rsi < 30,
                            sell: indicators.rsi > 70,
                            neutral: indicators.rsi >= 30 && indicators.rsi <= 70
                        }
                    },
                    gas_used: 2200,
                    state_changes: state
                };
            }
            
            // Existing trading functions remain the same
            execute_trading_function(state, call) {
                switch (call.function) {
                    case "buy":
                        return this.place_buy_order(state, call.params, call.caller);
                    case "sell":
                        return this.place_sell_order(state, call.params, call.caller);
                    case "cancel":
                        return this.cancel_order(state, call.params, call.caller);
                    default:
                        throw new Error("Unknown function: " + call.function);
                }
            }
            
            place_buy_order(state, params, caller) {
                const orderId = state.nextOrderId++;
                const order = {
                    id: orderId,
                    type: "buy",
                    asset: params.asset,
                    quantity: params.quantity,
                    price: params.price,
                    trader: caller,
                    timestamp: Date.now()
                };
                
                // Try to match with existing sell orders
                const trades = this.match_orders(order, state.orderBook.asks, state.trades);
                
                // Add remaining quantity to bids if any left
                if (order.quantity > 0) {
                    state.orderBook.bids.push(order);
                    state.orderBook.bids.sort((a, b) => b.price - a.price); // Highest price first
                }
                
                return {
                    success: true,
                    result: {
                        orderId: orderId,
                        trades: trades,
                        message: `Buy order placed: ${params.quantity} ${params.asset} @ ${params.price}`
                    },
                    gas_used: 1000,
                    state_changes: state
                };
            }
            
            place_sell_order(state, params, caller) {
                const orderId = state.nextOrderId++;
                const order = {
                    id: orderId,
                    type: "sell",
                    asset: params.asset,
                    quantity: params.quantity,
                    price: params.price,
                    trader: caller,
                    timestamp: Date.now()
                };
                
                // Try to match with existing buy orders
                const trades = this.match_orders(order, state.orderBook.bids, state.trades);
                
                // Add remaining quantity to asks if any left
                if (order.quantity > 0) {
                    state.orderBook.asks.push(order);
                    state.orderBook.asks.sort((a, b) => a.price - b.price); // Lowest price first
                }
                
                return {
                    success: true,
                    result: {
                        orderId: orderId,
                        trades: trades,
                        message: `Sell order placed: ${params.quantity} ${params.asset} @ ${params.price}`
                    },
                    gas_used: 1000,
                    state_changes: state
                };
            }
            
            cancel_order(state, params, caller) {
                const orderId = params.orderId;
                
                // Try to remove from bids
                let removed = false;
                state.orderBook.bids = state.orderBook.bids.filter(order => {
                    if (order.id === orderId && order.trader === caller) {
                        removed = true;
                        return false;
                    }
                    return true;
                });
                
                // Try to remove from asks if not found in bids
                if (!removed) {
                    state.orderBook.asks = state.orderBook.asks.filter(order => {
                        if (order.id === orderId && order.trader === caller) {
                            removed = true;
                            return false;
                        }
                        return true;
                    });
                }
                
                if (removed) {
                    return {
                        success: true,
                        result: { message: `Order ${orderId} cancelled` },
                        gas_used: 500,
                        state_changes: state
                    };
                } else {
                    return {
                        success: false,
                        error: "Order not found or not owned by caller",
                        gas_used: 100
                    };
                }
            }
            
            match_orders(order, oppositeOrders, tradesArray) {
                const trades = [];
                let remainingQuantity = order.quantity;
                
                for (let i = oppositeOrders.length - 1; i >= 0 && remainingQuantity > 0; i--) {
                    const oppositeOrder = oppositeOrders[i];
                    
                    // Check if prices match
                    const canTrade = (order.type === "buy" && order.price >= oppositeOrder.price) ||
                                   (order.type === "sell" && order.price <= oppositeOrder.price);
                    
                    if (canTrade && oppositeOrder.asset === order.asset) {
                        const tradeQuantity = Math.min(remainingQuantity, oppositeOrder.quantity);
                        const tradePrice = oppositeOrder.price; // Maker's price
                        
                        const trade = {
                            id: `trade_${Date.now()}_${Math.random()}`,
                            asset: order.asset,
                            quantity: tradeQuantity,
                            price: tradePrice,
                            buyer: order.type === "buy" ? order.trader : oppositeOrder.trader,
                            seller: order.type === "sell" ? order.trader : oppositeOrder.trader,
                            timestamp: Date.now()
                        };
                        
                        trades.push(trade);
                        tradesArray.push(trade);
                        
                        remainingQuantity -= tradeQuantity;
                        oppositeOrder.quantity -= tradeQuantity;
                        
                        if (oppositeOrder.quantity <= 0) {
                            oppositeOrders.splice(i, 1);
                        }
                    }
                }
                
                order.quantity = remainingQuantity;
                return trades;
            }
            
            get_order_book(asset = null) {
                const contract = this.contracts.get("trading_contract");
                if (!contract) {
                    return { bids: [], asks: [] };
                }
                
                let bids = contract.state.orderBook.bids || [];
                let asks = contract.state.orderBook.asks || [];
                
                if (asset) {
                    bids = bids.filter(order => order.asset === asset);
                    asks = asks.filter(order => order.asset === asset);
                }
                
                return { bids, asks };
            }
            
            get_recent_trades(asset = null, limit = 10) {
                const contract = this.contracts.get("trading_contract");
                if (!contract) {
                    return { trades: [] };
                }
                
                let trades = contract.state.trades || [];
                
                if (asset) {
                    trades = trades.filter(trade => trade.asset === asset);
                }
                
                // Return most recent trades
                trades = trades.slice(-limit).reverse();
                
                return { trades };
            }
            
            get_all_state() {
                const state = {};
                this.contracts.forEach((contract, id) => {
                    state[id] = contract.state;
                });
                return state;
            }
            
            restore_state(savedState) {
                // First initialize all contracts
                this.initializeMultiLanguageContracts();
                
                // Then restore any saved state
                if (savedState) {
                    Object.keys(savedState).forEach(contractId => {
                        const contract = this.contracts.get(contractId);
                        if (contract) {
                            contract.state = savedState[contractId];
                        }
                    });
                }
            }
            
            apply_state_changes(contractId, stateChanges) {
                const contract = this.contracts.get(contractId);
                if (contract && stateChanges) {
                    contract.state = stateChanges;
                }
            }

            // Contract editor functions
            list_contracts() {
                return Array.from(this.contracts.values());
            }
        }

        // Simple Contract Manager - integrated directly into main page
        class SimpleContractManager {
            constructor() {
                this.contracts = new Map();
                this.executionLog = [];
                this.isMonitoring = false;
                this.currentEditing = null;
                
                this.initializeContracts();
                this.setupExecutionInterception();
                this.updateUI();
            }
            
            initializeContracts() {
                // Initialize with existing contracts from blockchain
                if (window.blockchain && window.blockchain.contract_vm) {
                    const existingContracts = window.blockchain.contract_vm.list_contracts();
                    existingContracts.forEach(contract => {
                        this.contracts.set(contract.id, {
                            id: contract.id,
                            name: contract.name || contract.id,
                            runtime: contract.runtime || "javascript",
                            code: this.getContractCode(contract.id),
                            functions: this.extractFunctions(this.getContractCode(contract.id)),
                            executions: 0,
                            lastExecuted: null,
                            status: 'idle'
                        });
                    });
                }
                
                // Add default contracts if none exist
                if (this.contracts.size === 0) {
                    this.addDefaultContracts();
                }
            }
            
            addDefaultContracts() {
                const tradingContract = {
                    id: "trading_contract",
                    name: "Trading Contract",
                    runtime: "javascript",
                    code: `function buy(params) {
    const { asset, quantity, price } = params;
    if (!asset || quantity <= 0 || price <= 0) {
        throw new Error("Invalid parameters");
    }
    
    const orderId = this.state.nextOrderId || 1;
    this.state.nextOrderId = orderId + 1;
    
    if (!this.state.orderBook) {
        this.state.orderBook = { bids: [], asks: [] };
    }
    
    const order = {
        id: orderId,
        type: "buy",
        asset: asset,
        quantity: quantity,
        price: price,
        trader: this.caller,
        timestamp: Date.now()
    };
    
    this.state.orderBook.bids.push(order);
    
    return {
        orderId: orderId,
        message: \`Buy order placed: \${quantity} \${asset} @ \${price}\`
    };
}

function sell(params) {
    const { asset, quantity, price } = params;
    if (!asset || quantity <= 0 || price <= 0) {
        throw new Error("Invalid parameters");
    }
    
    const orderId = this.state.nextOrderId || 1;
    this.state.nextOrderId = orderId + 1;
    
    if (!this.state.orderBook) {
        this.state.orderBook = { bids: [], asks: [] };
    }
    
    const order = {
        id: orderId,
        type: "sell",
        asset: asset,
        quantity: quantity,
        price: price,
        trader: this.caller,
        timestamp: Date.now()
    };
    
    this.state.orderBook.asks.push(order);
    
    return {
        orderId: orderId,
        message: \`Sell order placed: \${quantity} \${asset} @ \${price}\`
    };
}

function getOrderBook() {
    return this.state.orderBook || { bids: [], asks: [] };
}`,
                    functions: ["buy", "sell", "getOrderBook"],
                    executions: 0,
                    lastExecuted: null,
                    status: 'idle'
                };
                
                this.contracts.set("trading_contract", tradingContract);
            }
            
            getContractCode(contractId) {
                // Try to get code from existing blockchain contract
                if (window.blockchain && window.blockchain.contract_vm) {
                    const contract = window.blockchain.contract_vm.contracts.get(contractId);
                    if (contract && contract.code) {
                        return contract.code;
                    }
                }
                
                // Return default code
                return `// Contract: ${contractId}
function example(params) {
    return { message: "Hello from " + "${contractId}" };
}`;
            }
            
            extractFunctions(code) {
                const functionRegex = /function\s+(\w+)\s*\(/g;
                const functions = [];
                let match;
                
                while ((match = functionRegex.exec(code)) !== null) {
                    functions.push(match[1]);
                }
                
                return functions;
            }
            
            setupExecutionInterception() {
                // Intercept contract calls to track executions
                if (window.blockchain && window.blockchain.call_contract) {
                    const originalCallContract = window.blockchain.call_contract.bind(window.blockchain);
                    
                    window.blockchain.call_contract = (call, sender) => {
                        // Track execution start
                        this.logExecution('start', call.contract_id, call.function, call.params);
                        
                        try {
                            const result = originalCallContract(call, sender);
                            
                            // Track successful execution
                            this.logExecution('success', call.contract_id, call.function, call.params, result);
                            
                            // Update contract status
                            const contract = this.contracts.get(call.contract_id);
                            if (contract) {
                                contract.executions++;
                                contract.lastExecuted = Date.now();
                                contract.status = 'active';
                                
                                setTimeout(() => {
                                    contract.status = 'idle';
                                    this.updateUI();
                                }, 2000);
                            }
                            
                            this.updateUI();
                            return result;
                            
                        } catch (error) {
                            // Track failed execution
                            this.logExecution('error', call.contract_id, call.function, call.params, null, error);
                            
                            const contract = this.contracts.get(call.contract_id);
                            if (contract) {
                                contract.status = 'error';
                                setTimeout(() => {
                                    contract.status = 'idle';
                                    this.updateUI();
                                }, 3000);
                            }
                            
                            this.updateUI();
                            throw error;
                        }
                    };
                }
            }
            
            logExecution(type, contractId, functionName, params, result, error) {
                if (!this.isMonitoring) return;
                
                const timestamp = new Date().toLocaleTimeString();
                const contract = this.contracts.get(contractId);
                const contractName = contract ? contract.name : contractId;
                
                let message, logClass;
                
                switch (type) {
                    case 'start':
                        message = `[${timestamp}] Executing ${contractName}.${functionName}(${JSON.stringify(params)})`;
                        logClass = 'log-info';
                        break;
                    case 'success':
                        message = `[${timestamp}] ${contractName}.${functionName}() completed successfully`;
                        if (result && result.result) {
                            message += ` → ${JSON.stringify(result.result)}`;
                        }
                        logClass = 'log-success';
                        break;
                    case 'error':
                        message = `[${timestamp}] ${contractName}.${functionName}() failed: ${error.message}`;
                        logClass = 'log-error';
                        break;
                }
                
                this.addLogEntry(message, logClass);
                
                this.executionLog.push({
                    timestamp: Date.now(),
                    type: type,
                    contractId: contractId,
                    contractName: contractName,
                    function: functionName,
                    params: params,
                    result: result,
                    error: error?.message
                });
            }
            
            addLogEntry(message, className) {
                const logDiv = document.getElementById('execution-log');
                if (!logDiv) return;
                
                const entry = document.createElement('div');
                entry.className = `log-entry ${className}`;
                entry.textContent = message;
                
                logDiv.appendChild(entry);
                
                // Auto-scroll if enabled
                const autoScroll = document.getElementById('auto-scroll');
                if (autoScroll && autoScroll.checked) {
                    logDiv.scrollTop = logDiv.scrollHeight;
                }
                
                // Keep only last 100 entries
                while (logDiv.children.length > 100) {
                    logDiv.removeChild(logDiv.firstChild);
                }
            }
            
            updateUI() {
                const listContainer = document.getElementById('contract-list');
                if (!listContainer) return;
                
                listContainer.innerHTML = '';
                
                this.contracts.forEach(contract => {
                    const card = document.createElement('div');
                    card.className = 'contract-card';
                    
                    let statusBadge;
                    switch (contract.status) {
                        case 'active':
                            statusBadge = '<span class="execution-badge execution-active">EXECUTING</span>';
                            break;
                        case 'error':
                            statusBadge = '<span class="execution-badge execution-error">ERROR</span>';
                            break;
                        default:
                            statusBadge = '<span class="execution-badge execution-idle">IDLE</span>';
                    }
                    
                    const styleInfo = contract.style && contract.style !== 'javascript' 
                        ? ` (${contract.style} style)` 
                        : '';
                    
                    card.innerHTML = `
                        <h4>${contract.name} 
                            <span class="runtime-badge runtime-${contract.runtime}">JavaScript${styleInfo}</span>
                            ${statusBadge}
                        </h4>
                        <p style="font-size: 12px; color: #666; margin: 5px 0;">
                            Functions: ${contract.functions.join(', ')}<br>
                            Executions: ${contract.executions} | 
                            Last: ${contract.lastExecuted ? new Date(contract.lastExecuted).toLocaleTimeString() : 'Never'}
                        </p>
                        <div>
                            <button class="btn btn-primary" onclick="editContract('${contract.id}')">Edit</button>
                            <button class="btn btn-success" onclick="testContractFromCard('${contract.id}')">Test</button>
                            <button class="btn btn-warning" onclick="deployContractFromCard('${contract.id}')">Deploy</button>
                            <button class="btn btn-danger" onclick="deleteContract('${contract.id}')">Delete</button>
                        </div>
                    `;
                    
                    listContainer.appendChild(card);
                });
            }
            
            editContract(contractId) {
                const contract = this.contracts.get(contractId);
                if (!contract) return;
                
                this.currentEditing = contractId;
                
                document.getElementById('editor-title').textContent = `Edit Contract: ${contract.name}`;
                document.getElementById('edit-contract-id').value = contract.id;
                document.getElementById('edit-contract-name').value = contract.name;
                document.getElementById('edit-contract-runtime').value = contract.style || 'javascript';
                document.getElementById('contract-code').value = contract.code;
                
                // Update test function dropdown
                const functionSelect = document.getElementById('test-function');
                functionSelect.innerHTML = '<option value="">Select function...</option>';
                contract.functions.forEach(func => {
                    const option = document.createElement('option');
                    option.value = func;
                    option.textContent = func;
                    functionSelect.appendChild(option);
                });
                
                document.getElementById('contract-editor-modal').style.display = 'block';
            }
            
            saveContract() {
                if (!this.currentEditing) return;
                
                const contract = this.contracts.get(this.currentEditing);
                const newCode = document.getElementById('contract-code').value;
                const newName = document.getElementById('edit-contract-name').value;
                const newStyle = document.getElementById('edit-contract-runtime').value;
                
                contract.name = newName;
                contract.code = newCode;
                contract.style = newStyle;
                contract.functions = this.extractFunctions(newCode);
                
                // Update in blockchain VM if it exists
                if (window.blockchain && window.blockchain.contract_vm) {
                    try {
                        const blockchainContract = window.blockchain.contract_vm.contracts.get(this.currentEditing);
                        if (blockchainContract) {
                            blockchainContract.code = newCode;
                            blockchainContract.name = newName;
                            blockchainContract.style = newStyle;
                        }
                    } catch (error) {
                        console.warn('Could not update blockchain contract:', error);
                    }
                }
                
                this.updateUI();
                alert('Contract saved successfully!');
            }
            
            deployContract() {
                this.saveContract();
                alert('Contract deployed successfully!');
            }
            
            testContract() {
                const functionName = document.getElementById('test-function').value;
                const paramsText = document.getElementById('test-params').value;
                
                if (!functionName) {
                    alert('Please select a function to test');
                    return;
                }
                
                let params = {};
                if (paramsText.trim()) {
                    try {
                        params = JSON.parse(paramsText);
                    } catch (error) {
                        alert('Invalid JSON in parameters');
                        return;
                    }
                }
                
                // Execute the contract via blockchain
                if (window.blockchain && window.blockchain.call_contract) {
                    try {
                        const result = window.blockchain.call_contract({
                            contract_id: this.currentEditing,
                            function: functionName,
                            params: params,
                            caller: 'test_user',
                            gas_limit: 50000
                        }, 'test_user');
                        
                        const resultDiv = document.getElementById('test-result');
                        resultDiv.style.display = 'block';
                        resultDiv.innerHTML = `
                            <h5>Test Result:</h5>
                            <pre style="background: white; padding: 10px; border-radius: 4px; font-size: 12px;">${JSON.stringify(result, null, 2)}</pre>
                        `;
                        
                    } catch (error) {
                        const resultDiv = document.getElementById('test-result');
                        resultDiv.style.display = 'block';
                        resultDiv.innerHTML = `
                            <h5>Test Failed:</h5>
                            <div style="color: red; padding: 10px; background: white; border-radius: 4px;">${error.message}</div>
                        `;
                    }
                } else {
                    alert('Blockchain system not available for testing');
                }
            }
            
            createNewContract() {
                const id = document.getElementById('new-contract-id').value.trim();
                const name = document.getElementById('new-contract-name').value.trim();
                const runtime = document.getElementById('new-contract-runtime').value;
                const code = document.getElementById('new-contract-code').value.trim();
                
                if (!id || !name || !code) {
                    alert('Please fill in all required fields');
                    return;
                }
                
                if (this.contracts.has(id)) {
                    alert('Contract with this ID already exists');
                    return;
                }
                
                const newContract = {
                    id: id,
                    name: name,
                    runtime: "javascript",
                    style: runtime,
                    code: code,
                    functions: this.extractFunctions(code),
                    executions: 0,
                    lastExecuted: null,
                    status: 'idle'
                };
                
                this.contracts.set(id, newContract);
                
                // Add to blockchain VM if available
                if (window.blockchain && window.blockchain.contract_vm) {
                    try {
                        window.blockchain.contract_vm.contracts.set(id, {
                            id: id,
                            name: name,
                            runtime: "javascript",
                            style: runtime,
                            code: code,
                            state: {},
                            created_at: Date.now()
                        });
                    } catch (error) {
                        console.warn('Could not add to blockchain VM:', error);
                    }
                }
                
                this.updateUI();
                this.closeNewContractDialog();
                alert(`Contract '${name}' created successfully!`);
            }
            
            deleteContract(contractId) {
                if (contractId === 'trading_contract') {
                    alert('Cannot delete the trading contract');
                    return;
                }
                
                if (confirm(`Are you sure you want to delete contract '${contractId}'?`)) {
                    this.contracts.delete(contractId);
                    
                    // Remove from blockchain VM if available
                    if (window.blockchain && window.blockchain.contract_vm) {
                        try {
                            window.blockchain.contract_vm.contracts.delete(contractId);
                        } catch (error) {
                            console.warn('Could not remove from blockchain VM:', error);
                        }
                    }
                    
                    this.updateUI();
                }
            }
            
            closeContractEditor() {
                document.getElementById('contract-editor-modal').style.display = 'none';
                this.currentEditing = null;
            }
            
            closeNewContractDialog() {
                document.getElementById('new-contract-modal').style.display = 'none';
                // Clear form
                document.getElementById('new-contract-id').value = '';
                document.getElementById('new-contract-name').value = '';
                document.getElementById('new-contract-code').value = '';
            }
            
            toggleExecutionMonitor() {
                this.isMonitoring = !this.isMonitoring;
                const button = document.getElementById('monitor-toggle');
                
                if (this.isMonitoring) {
		    this.setupExecutionInterception();
                    button.textContent = 'Stop Monitoring';
                    button.className = 'btn btn-danger';
                    this.addLogEntry('Contract execution monitoring started', 'log-success');
                } else {
                    button.textContent = 'Start Monitoring';
                    button.className = 'btn btn-success';
                    this.addLogEntry('Contract execution monitoring stopped', 'log-warning');
                }
            }
            
            clearExecutionLog() {
                const logDiv = document.getElementById('execution-log');
                if (logDiv) {
                    logDiv.innerHTML = '';
                }
                this.executionLog = [];
                this.addLogEntry('Execution log cleared', 'log-info');
            }
        }

        // MeshManager class with FULL WebRTC implementation
        class MeshManager {
            constructor() {
                this.ws = null;
                this.peers = new Map();
                this.dataChannels = new Map();
                this.availablePeers = [];
                this.connected = false;
                this.currentNetwork = null;
                this.networkPeerCount = 0;
                this.serverUrl = '';
                this.peerId = null;
            }
            
            async connect() {
                try {
                    const serverInput = document.getElementById('server-input').value.trim();
                    const server = serverInput || `${window.location.hostname}:3030`;
                    this.serverUrl = server;
                    const wsUrl = `ws://${server}/ws`;
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.connected = true;
                        log('Connected to tracker');
                        this.refreshNetworkList();
                        updateUI();
                    };
                    
                    this.ws.onclose = () => {
                        this.connected = false;
                        log('Disconnected from tracker');
                        updateUI();
                    };
                    
                    this.ws.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    };
                    
                } catch (error) {
                    log('Connection failed: ' + error.message);
                }
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'network_list_update':
                        this.updateNetworkDropdown(message.networks);
                        break;
                        
                    case 'network_info':
                        this.currentNetwork = message.network_id;
                        this.networkPeerCount = message.peer_count;
                        log('Joined network: ' + message.network_id);
                        blockchain.loadFromStorage();
                        updateUI();
                        setTimeout(() => {
                            updateOrderBookFromContract();
                        }, 100);
                        break;
                        
                    case 'peers':
                        this.availablePeers = message.peers;
                        log('Available peers: ' + message.peers.length);
                        updateUI();
                        break;
                        
                    case 'offer':
                        this.handleOffer(message.target, message.offer);
                        break;
                        
                    case 'answer':
                        this.handleAnswer(message.target, message.answer);
                        break;
                        
                    case 'candidate':
                        this.handleCandidate(message.target, message.candidate);
                        break;
                        
                    case 'block':
                        blockchain.addBlock(message.block);
                        log('Received block #' + message.block.id);
                        updateUI();
                        updateOrderBookFromContract();
                        break;
                        
                    case 'transaction':
                        if (message.transaction.type === 'message') {
                            blockchain.addMessage(message.transaction.data, message.transaction.sender);
                        } else if (message.transaction.type === 'contract_call') {
                            // Apply the contract call state changes
                            if (message.transaction.result && message.transaction.result.success) {
                                blockchain.contract_vm.apply_state_changes(
                                    message.transaction.call.contract_id, 
                                    message.transaction.result.state_changes
                                );
                            }
                            blockchain.pending.push(message.transaction);
                        }
                        log('Received transaction');
                        updateUI();
                        updateOrderBookFromContract();
                        break;
                }
            }

            // COMPLETE WebRTC implementation
            async connectToPeer(peerId) {
                if (this.peers.has(peerId)) {
                    log(`Already connected to peer ${peerId.substring(0, 8)}`);
                    return;
                }

                try {
                    const peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });

                    this.peers.set(peerId, peerConnection);

                    // Set up ICE candidate handling
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.send({
                                type: 'candidate',
                                target: peerId,
                                candidate: event.candidate
                            });
                        }
                    };

                    // Create data channel
                    const dataChannel = peerConnection.createDataChannel('blockchain', {
                        ordered: true
                    });
                    
                    this.setupDataChannel(dataChannel, peerId);

                    // Create offer
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);

                    this.send({
                        type: 'offer',
                        target: peerId,
                        offer: offer
                    });

                    log(`Sent connection offer to peer ${peerId.substring(0, 8)}`);
                } catch (error) {
                    log(`Failed to connect to peer ${peerId.substring(0, 8)}: ${error.message}`);
                    this.peers.delete(peerId);
                }
            }

            async handleOffer(peerId, offer) {
                try {
                    const peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });

                    this.peers.set(peerId, peerConnection);

                    // Set up ICE candidate handling
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.send({
                                type: 'candidate',
                                target: peerId,
                                candidate: event.candidate
                            });
                        }
                    };

                    // Handle incoming data channel
                    peerConnection.ondatachannel = (event) => {
                        const dataChannel = event.channel;
                        this.setupDataChannel(dataChannel, peerId);
                    };

                    // Set remote description
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                    // Create answer
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    this.send({
                        type: 'answer',
                        target: peerId,
                        answer: answer
                    });

                    log(`Sent connection answer to peer ${peerId.substring(0, 8)}`);
                } catch (error) {
                    log(`Failed to handle offer from peer ${peerId.substring(0, 8)}: ${error.message}`);
                    this.peers.delete(peerId);
                }
            }

            async handleAnswer(peerId, answer) {
                try {
                    const peerConnection = this.peers.get(peerId);
                    if (!peerConnection) {
                        log(`No peer connection found for ${peerId.substring(0, 8)}`);
                        return;
                    }

                    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    log(`Received connection answer from peer ${peerId.substring(0, 8)}`);
                } catch (error) {
                    log(`Failed to handle answer from peer ${peerId.substring(0, 8)}: ${error.message}`);
                }
            }

            async handleCandidate(peerId, candidate) {
                try {
                    const peerConnection = this.peers.get(peerId);
                    if (!peerConnection) {
                        log(`No peer connection found for candidate from ${peerId.substring(0, 8)}`);
                        return;
                    }

                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (error) {
                    log(`Failed to add ICE candidate from peer ${peerId.substring(0, 8)}: ${error.message}`);
                }
            }

            setupDataChannel(dataChannel, peerId) {
                dataChannel.onopen = () => {
                    log(`Data channel opened with peer ${peerId.substring(0, 8)}`);
                    this.dataChannels.set(peerId, dataChannel);
                    updateUI();
                };

                dataChannel.onclose = () => {
                    log(`Data channel closed with peer ${peerId.substring(0, 8)}`);
                    this.dataChannels.delete(peerId);
                    this.peers.delete(peerId);
                    updateUI();
                };

                dataChannel.onerror = (error) => {
                    log(`Data channel error with peer ${peerId.substring(0, 8)}: ${error}`);
                };

                dataChannel.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        this.handleMessage(message);
                    } catch (error) {
                        log(`Failed to parse message from peer ${peerId.substring(0, 8)}: ${error.message}`);
                    }
                };
            }

            async connectToAll() {
                if (!this.availablePeers || this.availablePeers.length === 0) {
                    log('No available peers to connect to');
                    return;
                }

                log(`Connecting to ${this.availablePeers.length} peers...`);
                for (const peerId of this.availablePeers) {
                    if (!this.dataChannels.has(peerId)) {
                        await this.connectToPeer(peerId);
                        // Small delay to avoid overwhelming the connection process
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
            }

            updateNetworkDropdown(networks) {
                const select = document.getElementById('network-select');
                while (select.children.length > 1) {
                    select.removeChild(select.lastChild);
                }
                networks.forEach(network => {
                    const option = document.createElement('option');
                    option.value = network.id;
                    option.textContent = `${network.name} (${network.peer_count} peers)`;
                    select.appendChild(option);
                });
            }

            async refreshNetworkList() {
                if (!this.serverUrl) return;
                try {
                    const response = await fetch(`http://${this.serverUrl}/api/network-list`);
                    const networks = await response.json();
                    this.updateNetworkDropdown(networks);
                } catch (error) {
                    log('Failed to fetch network list: ' + error.message);
                }
            }

            getSelectedNetwork() {
                const selectValue = document.getElementById('network-select').value;
                const inputValue = document.getElementById('network-input').value.trim();
                return selectValue || inputValue || null;
            }

            joinNetwork(networkId) {
                if (this.connected && networkId) {
                    this.send({
                        type: 'join_network',
                        network_id: networkId
                    });
                    log('Joining network: ' + networkId);
                }
            }

            send(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                    
                    // Log blockchain updates for debugging
                    if (message.type === 'blockchain_update') {
                        log(`Sending blockchain update with ${message.new_blocks.length} blocks`);
                    }
                } else {
                    log('Cannot send message - WebSocket not open');
                }
            }

            broadcast(message) {
                this.dataChannels.forEach((dc) => {
                    if (dc.readyState === 'open') {
                        dc.send(JSON.stringify(message));
                    }
                });
            }
        }

        // Contract Templates
        const CONTRACT_TEMPLATES = {
            counter: `function increment(params) {
    const amount = params.amount || 1;
    this.state.count = (this.state.count || 0) + amount;
    
    return {
        count: this.state.count,
        message: \`Incremented by \${amount}, new count: \${this.state.count}\`
    };
}

function decrement(params) {
    const amount = params.amount || 1;
    this.state.count = (this.state.count || 0) - amount;
    
    return {
        count: this.state.count,
        message: \`Decremented by \${amount}, new count: \${this.state.count}\`
    };
}

function getCount() {
    return { count: this.state.count || 0 };
}

function reset() {
    this.state.count = 0;
    return { count: 0, message: "Counter reset to 0" };
}`,
            
            'counter-rust': `function increment(params) {
    let amount = params.amount || 1;
    let current_count = this.state.count || 0;
    
    this.state.count = current_count + amount;
    
    return {
        count: this.state.count,
        message: \`incremented_by_\${amount}_new_count_\${this.state.count}\`
    };
}

function decrement(params) {
    let amount = params.amount || 1;
    let current_count = this.state.count || 0;
    
    this.state.count = current_count - amount;
    
    return {
        count: this.state.count,
        message: \`decremented_by_\${amount}_new_count_\${this.state.count}\`
    };
}

function get_count() {
    return { count: this.state.count || 0 };
}

function reset_counter() {
    this.state.count = 0;
    return { count: 0, message: "counter_reset_to_zero" };
}`,

            'counter-python': `function increment(params) {
    const amount = params.amount || 1;
    const current_count = this.state.count || 0;
    
    this.state.count = current_count + amount;
    
    return {
        'count': this.state.count,
        'message': \`Incremented by \${amount}, new count: \${this.state.count}\`
    };
}

function decrement(params) {
    const amount = params.amount || 1;
    const current_count = this.state.count || 0;
    
    this.state.count = current_count - amount;
    
    return {
        'count': this.state.count,
        'message': \`Decremented by \${amount}, new count: \${this.state.count}\`
    };
}

function get_count() {
    return {'count': this.state.count || 0};
}

function reset() {
    this.state.count = 0;
    return {'count': 0, 'message': 'Counter reset to 0'};
}`,

            voting: `function createProposal(params) {
    const { title, description } = params;
    if (!title) throw new Error("Title required");
    
    if (!this.state.proposals) this.state.proposals = [];
    
    const proposal = {
        id: this.state.proposals.length,
        title: title,
        description: description || "",
        votes: { yes: 0, no: 0 },
        voters: [],
        created: Date.now(),
        creator: this.caller
    };
    
    this.state.proposals.push(proposal);
    
    return {
        proposalId: proposal.id,
        message: \`Proposal "\${title}" created\`
    };
}

function vote(params) {
    const { proposalId, vote } = params;
    if (!this.state.proposals || !this.state.proposals[proposalId]) {
        throw new Error("Proposal not found");
    }
    
    const proposal = this.state.proposals[proposalId];
    
    if (proposal.voters.includes(this.caller)) {
        throw new Error("Already voted");
    }
    
    if (vote === "yes") {
        proposal.votes.yes++;
    } else if (vote === "no") {
        proposal.votes.no++;
    } else {
        throw new Error("Vote must be 'yes' or 'no'");
    }
    
    proposal.voters.push(this.caller);
    
    return {
        proposal: proposal,
        message: \`Voted \${vote} on "\${proposal.title}"\`
    };
}

function getProposals() {
    return { proposals: this.state.proposals || [] };
}`,

            token: `function mint(params) {
    const { to, amount } = params;
    if (!to || amount <= 0) throw new Error("Invalid parameters");
    
    if (!this.state.balances) this.state.balances = {};
    if (!this.state.totalSupply) this.state.totalSupply = 0;
    
    this.state.balances[to] = (this.state.balances[to] || 0) + amount;
    this.state.totalSupply += amount;
    
    return {
        to: to,
        amount: amount,
        newBalance: this.state.balances[to],
        totalSupply: this.state.totalSupply,
        message: \`Minted \${amount} tokens to \${to}\`
    };
}

function transfer(params) {
    const { to, amount } = params;
    if (!to || amount <= 0) throw new Error("Invalid parameters");
    
    const fromBalance = this.state.balances[this.caller] || 0;
    if (fromBalance < amount) throw new Error("Insufficient balance");
    
    this.state.balances[this.caller] = fromBalance - amount;
    this.state.balances[to] = (this.state.balances[to] || 0) + amount;
    
    return {
        from: this.caller,
        to: to,
        amount: amount,
        message: \`Transferred \${amount} tokens to \${to}\`
    };
}

function balanceOf(params) {
    const { account } = params;
    return {
        account: account,
        balance: this.state.balances[account] || 0
    };
}

function totalSupply() {
    return { totalSupply: this.state.totalSupply || 0 };
}`,

            marketplace: `function listItem(params) {
    const { name, description, price } = params;
    if (!name || price <= 0) throw new Error("Invalid parameters");
    
    if (!this.state.items) this.state.items = [];
    
    const item = {
        id: this.state.items.length,
        name: name,
        description: description || "",
        price: price,
        seller: this.caller,
        sold: false,
        created: Date.now()
    };
    
    this.state.items.push(item);
    
    return {
        itemId: item.id,
        message: \`Listed "\${name}" for \${price}\`
    };
}

function buyItem(params) {
    const { itemId } = params;
    if (!this.state.items || !this.state.items[itemId]) {
        throw new Error("Item not found");
    }
    
    const item = this.state.items[itemId];
    if (item.sold) throw new Error("Item already sold");
    if (item.seller === this.caller) throw new Error("Cannot buy your own item");
    
    item.sold = true;
    item.buyer = this.caller;
    item.soldAt = Date.now();
    
    return {
        item: item,
        message: \`Purchased "\${item.name}" for \${item.price}\`
    };
}

function getItems() {
    return {
        items: (this.state.items || []).filter(item => !item.sold)
    };
}

function getMySales() {
    return {
        sales: (this.state.items || []).filter(item => item.seller === this.caller)
    };
}`
        };

        // Global instances
        const mesh = new MeshManager();
        const blockchain = new SmartBlockchain();
        const contractManager = new SimpleContractManager();
        window.mesh = mesh;
        window.blockchain = blockchain;
        window.contractManager = contractManager;

        // Global functions for UI interaction
        function editContract(contractId) {
            contractManager.editContract(contractId);
        }

        function saveContract() {
            contractManager.saveContract();
        }

        function deployContract() {
            contractManager.deployContract();
        }

        function testContract() {
            contractManager.testContract();
        }

        function testContractFromCard(contractId) {
            contractManager.editContract(contractId);
            setTimeout(() => {
                document.getElementById('test-function').focus();
            }, 100);
        }

        function deployContractFromCard(contractId) {
            log(`Contract '${contractId}' deployed successfully!`);
        }

        function deleteContract(contractId) {
            contractManager.deleteContract(contractId);
        }

        function closeContractEditor() {
            contractManager.closeContractEditor();
        }

        function showNewContractDialog() {
            document.getElementById('new-contract-modal').style.display = 'block';
        }

        function closeNewContractDialog() {
            contractManager.closeNewContractDialog();
        }

        function createNewContract() {
            contractManager.createNewContract();
        }

        function loadContractTemplate() {
            const template = document.getElementById('contract-template').value;
            const codeTextarea = document.getElementById('new-contract-code');
            
            if (template && CONTRACT_TEMPLATES[template]) {
                codeTextarea.value = CONTRACT_TEMPLATES[template];
            } else {
                codeTextarea.value = '';
            }
        }

        function refreshContracts() {
            contractManager.updateUI();
        }

        function exportContracts() {
            const contracts = Array.from(contractManager.contracts.values());
            const data = JSON.stringify(contracts, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `contracts_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function toggleExecutionMonitor() {
            contractManager.toggleExecutionMonitor();
        }

        function clearExecutionLog() {
            contractManager.clearExecutionLog();
        }

        // Trading functions - NOW CALLING ACTUAL RUST SMART CONTRACTS
        function placeBuyOrder() {
            const asset = document.getElementById('buy-asset').value;
            const quantity = parseFloat(document.getElementById('buy-quantity').value);
            const price = parseFloat(document.getElementById('buy-price').value);
            
            if (!asset || !quantity || !price || quantity <= 0 || price <= 0) {
                log('Invalid buy order parameters');
                return;
            }

            // Call the actual smart contract
            const call = {
                contract_id: "trading_contract",
                function: "buy",
                params: {
                    asset: asset,
                    quantity: quantity,
                    price: price
                },
                caller: getUserId(),
                gas_limit: 50000
            };
            
            // Execute the contract call through the blockchain
            const tx = blockchain.call_contract(call, getUserId());
            
            if (mesh.connected) {
                const txMessage = { type: 'transaction', transaction: tx };
                mesh.send(txMessage);
                mesh.broadcast(txMessage);
            }

            log(`Buy order placed: ${quantity} ${asset} @ ${price} (Contract call created)`);
            
            // Clear form
            document.getElementById('buy-quantity').value = '';
            document.getElementById('buy-price').value = '';
            
            updateUI();
            updateOrderBookFromContract();
            
            // Auto-mine if we have pending contract transactions
            if (blockchain.pending.length > 0) {
                setTimeout(() => {
                    if (confirm('Mine block to include this contract transaction in blockchain?')) {
                        document.getElementById('mine-btn').click();
                    }
                }, 500);
            }
        }

        function placeSellOrder() {
            const asset = document.getElementById('sell-asset').value;
            const quantity = parseFloat(document.getElementById('sell-quantity').value);
            const price = parseFloat(document.getElementById('sell-price').value);
            
            if (!asset || !quantity || !price || quantity <= 0 || price <= 0) {
                log('Invalid sell order parameters');
                return;
            }

            // Call the actual smart contract
            const call = {
                contract_id: "trading_contract",
                function: "sell",
                params: {
                    asset: asset,
                    quantity: quantity,
                    price: price
                },
                caller: getUserId(),
                gas_limit: 50000
            };
            
            // Execute the contract call through the blockchain
            const tx = blockchain.call_contract(call, getUserId());
            
            if (mesh.connected) {
                const txMessage = { type: 'transaction', transaction: tx };
                mesh.send(txMessage);
                mesh.broadcast(txMessage);
            }

            log(`Sell order placed: ${quantity} ${asset} @ ${price} (Contract call created)`);
            
            // Clear form
            document.getElementById('sell-quantity').value = '';
            document.getElementById('sell-price').value = '';
            
            updateUI();
            updateOrderBookFromContract();
            
            // Auto-mine if we have pending contract transactions
            if (blockchain.pending.length > 0) {
                setTimeout(() => {
                    if (confirm('Mine block to include this contract transaction in blockchain?')) {
                        document.getElementById('mine-btn').click();
                    }
                }, 500);
            }
        }

        // Order book display function - reads from actual smart contract
        function updateOrderBookFromContract() {
            try {
                // Get order book data from the smart contract
                const orderBookData = blockchain.get_order_book();
                
                const bidsTableBody = document.getElementById('bids-tbody');
                const asksTableBody = document.getElementById('asks-tbody');
                
                if (!bidsTableBody || !asksTableBody) {
                    return; // Elements not found, skip update
                }
                
                // Update bids (buy orders)
                if (orderBookData.bids && orderBookData.bids.length > 0) {
                    bidsTableBody.innerHTML = orderBookData.bids.map(order => `
                        <tr class="bid-row">
                            <td>${order.price}</td>
                            <td>${order.quantity}</td>
                            <td>${order.trader.substring(0, 8)}</td>
                            <td><button onclick="cancelContractOrder(${order.id})">Cancel</button></td>
                        </tr>
                    `).join('');
                } else {
                    bidsTableBody.innerHTML = '<tr><td colspan="4">No buy orders</td></tr>';
                }
                
                // Update asks (sell orders)
                if (orderBookData.asks && orderBookData.asks.length > 0) {
                    asksTableBody.innerHTML = orderBookData.asks.map(order => `
                        <tr class="ask-row">
                            <td>${order.price}</td>
                            <td>${order.quantity}</td>
                            <td>${order.trader.substring(0, 8)}</td>
                            <td><button onclick="cancelContractOrder(${order.id})">Cancel</button></td>
                        </tr>
                    `).join('');
                } else {
                    asksTableBody.innerHTML = '<tr><td colspan="4">No sell orders</td></tr>';
                }

                // Update recent trades
                updateRecentTrades();
                
            } catch (error) {
                console.log('Error updating order book from contract:', error);
                log('Error loading order book: ' + error.message);
            }
        }

        function updateRecentTrades() {
            try {
                const tradesData = blockchain.get_recent_trades(null, 10);
                const tradesTableBody = document.getElementById('trades-tbody');
                
                if (!tradesTableBody) return;
                
                if (tradesData.trades && tradesData.trades.length > 0) {
                    tradesTableBody.innerHTML = tradesData.trades.map(trade => `
                        <tr class="trade-row">
                            <td>${new Date(trade.timestamp).toLocaleTimeString()}</td>
                            <td>${trade.asset}</td>
                            <td>${trade.quantity}</td>
                            <td>${trade.price}</td>
                            <td>${trade.buyer.substring(0, 8)}</td>
                            <td>${trade.seller.substring(0, 8)}</td>
                        </tr>
                    `).join('');
                } else {
                    tradesTableBody.innerHTML = '<tr><td colspan="6">No recent trades</td></tr>';
                }
            } catch (error) {
                console.log('Error updating recent trades:', error);
            }
        }

        function cancelContractOrder(orderId) {
            try {
                const call = {
                    contract_id: "trading_contract",
                    function: "cancel",
                    params: {
                        orderId: orderId
                    },
                    caller: getUserId(),
                    gas_limit: 30000
                };
                
                const tx = blockchain.call_contract(call, getUserId());
                
                if (mesh.connected) {
                    const txMessage = { type: 'transaction', transaction: tx };
                    mesh.send(txMessage);
                    mesh.broadcast(txMessage);
                }
                
                log(`Order ${orderId} cancelled`);
                updateOrderBookFromContract();
                
            } catch (error) {
                log('Error cancelling order: ' + error.message);
            }
        }

        // Multi-language contract calls
        function callPythonPredictor() {
            const asset = document.getElementById('buy-asset').value || 'BTC';
            
            const call = {
                contract_id: "ml_predictor",
                function: "predict_price",
                params: { asset: asset },
                caller: getUserId(),
                gas_limit: 5000
            };
            
            const tx = blockchain.call_contract(call, getUserId());
            
            if (mesh.connected) {
                const txMessage = { type: 'transaction', transaction: tx };
                mesh.send(txMessage);
                mesh.broadcast(txMessage);
            }
            
            if (tx.result && tx.result.success) {
                const prediction = tx.result.result;
                log(`Python ML Prediction for ${asset}: ${prediction.predicted_price} (confidence: ${Math.round(prediction.confidence * 100)}%)`);
            }
            
            updateUI();
            
            if (blockchain.pending.length > 0) {
                setTimeout(() => {
                    if (confirm('Mine block to include Python ML prediction?')) {
                        document.getElementById('mine-btn').click();
                    }
                }, 500);
            }
        }
        
        function callWasmDeFi() {
            const assetA = document.getElementById('buy-asset').value || 'BTC';
            const assetB = document.getElementById('sell-asset').value || 'ETH';
            
            const call = {
                contract_id: "defi_pool",
                function: "add_liquidity",
                params: {
                    asset_a: assetA,
                    asset_b: assetB,
                    amount_a: 1.0,
                    amount_b: 20.0
                },
                caller: getUserId(),
                gas_limit: 8000
            };
            
            const tx = blockchain.call_contract(call, getUserId());
            
            if (mesh.connected) {
                const txMessage = { type: 'transaction', transaction: tx };
                mesh.send(txMessage);
                mesh.broadcast(txMessage);
            }
            
            if (tx.result && tx.result.success) {
                const result = tx.result.result;
                log(`WASM DeFi: Added liquidity to ${result.pool}, minted ${result.shares_minted} shares`);
            }
            
            updateUI();
            
            if (blockchain.pending.length > 0) {
                setTimeout(() => {
                    if (confirm('Mine block to include WASM DeFi transaction?')) {
                        document.getElementById('mine-btn').click();
                    }
                }, 500);
            }
        }
        
        function callJavaScriptAnalytics() {
            const asset = document.getElementById('buy-asset').value || 'BTC';
            
            const call = {
                contract_id: "js_analytics",
                function: "analyze_market",
                params: { asset: asset },
                caller: getUserId(),
                gas_limit: 3000
            };
            
            const tx = blockchain.call_contract(call, getUserId());
            
            if (mesh.connected) {
                const txMessage = { type: 'transaction', transaction: tx };
                mesh.send(txMessage);
                mesh.broadcast(txMessage);
            }
            
            if (tx.result && tx.result.success) {
                const analysis = tx.result.result;
                log(`JavaScript Analytics for ${asset}: ${analysis.recommendation} (volume: ${analysis.volume_24h}, change: ${analysis.price_change_pct}%)`);
            }
            
            updateUI();
            
            if (blockchain.pending.length > 0) {
                setTimeout(() => {
                    if (confirm('Mine block to include JavaScript analytics?')) {
                        document.getElementById('mine-btn').click();
                    }
                }, 500);
            }
        }

        function showContractState(contractId) {
            try {
                const contract = blockchain.contract_vm.contracts.get(contractId);
                if (!contract) {
                    log(`Contract ${contractId} not found`);
                    return;
                }
                
                const stateDisplay = document.getElementById('contract-state-display');
                const stateContent = document.getElementById('contract-state-content');
                
                const displayData = {
                    contract_id: contract.id,
                    name: contract.name,
                    runtime: contract.runtime,
                    created_at: new Date(contract.created_at).toLocaleString(),
                    state: contract.state
                };
                
                stateContent.textContent = JSON.stringify(displayData, null, 2);
                stateDisplay.style.display = 'block';
                
                log(`Displaying state for ${contract.name} (${contract.runtime})`);
                
            } catch (error) {
                log(`Error displaying contract state: ${error.message}`);
            }
        }

        function testBlockchainSync() {
            if (!mesh.connected || !mesh.currentNetwork) {
                log('Not connected to network - cannot sync');
                return;
            }
            
            log('Testing blockchain sync to enterprise...');
            blockchain.sendBlockchainUpdate();
        }

        function getUserId() {
            if (!window.userId) {
                window.userId = 'user_' + Math.random().toString(36).substr(2, 9);
            }
            return window.userId;
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab + '-tab').classList.add('active');
            });
        });

        // UI functions
        function log(message) {
            const logDiv = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += time + ': ' + message + '\n';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateUI() {
            document.getElementById('peer-count').textContent = mesh.dataChannels ? mesh.dataChannels.size : 0;
            document.getElementById('block-count').textContent = blockchain.chain.length;
            document.getElementById('pending-count').textContent = blockchain.pending.length;
            document.getElementById('status').textContent = mesh.connected ? 'Connected' : 'Offline';
            document.getElementById('network-name').textContent = mesh.currentNetwork || 'None';

            const hasNetwork = mesh.currentNetwork;
            const hasPeers = mesh.dataChannels && mesh.dataChannels.size > 0;
            const hasBlocks = blockchain.chain.length > 1; // More than genesis
            
            document.getElementById('connect-btn').textContent = mesh.connected ? 'Disconnect' : 'Connect';
            document.getElementById('join-network-btn').disabled = !mesh.connected;
            document.getElementById('discover-btn').disabled = !hasNetwork;
            document.getElementById('connect-all-btn').disabled = !hasNetwork || !mesh.availablePeers || mesh.availablePeers.length === 0;
            document.getElementById('send-btn').disabled = !hasPeers;
            document.getElementById('mine-btn').disabled = blockchain.pending.length === 0;
            document.getElementById('sync-blockchain-btn').disabled = !hasNetwork || !hasBlocks;
            
            updateBlockchain();
            updatePeersList();
        }

        function updateBlockchain() {
            // Update pending transactions display
            const pendingDiv = document.getElementById('pending-transactions');
            if (blockchain.pending.length > 0) {
                const pendingHtml = blockchain.pending.map((tx, i) => {
                    if (tx.type === 'contract_call') {
                        return `${i+1}. Smart Contract: ${tx.call.function}(${JSON.stringify(tx.call.params)}) - Gas: ${tx.result?.gas_used || 'pending'}`;
                    } else if (tx.type === 'message') {
                        return `${i+1}. Message: "${tx.data}"`;
                    }
                    return `${i+1}. ${tx.type}`;
                }).join('<br>');
                
                pendingDiv.innerHTML = `
                    <div style="background: #fff3cd; padding: 10px; border-radius: 4px; border-left: 4px solid #ffc107;">
                        <strong>Pending Transactions (${blockchain.pending.length}):</strong><br>
                        ${pendingHtml}
                        <br><br>
                        <button onclick="document.getElementById('mine-btn').click()" style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 3px;">
                            Mine Block Now
                        </button>
                    </div>
                `;
            } else {
                pendingDiv.innerHTML = '';
            }
            
            const blockchainDiv = document.getElementById('blockchain');
            blockchainDiv.innerHTML = '';
            
            blockchain.chain.forEach((block) => {
                const blockDiv = document.createElement('div');
                blockDiv.className = 'block';
                
                // Show transaction details
                let transactionDetails = '';
                if (block.transactions && block.transactions.length > 0) {
                    transactionDetails = '<div class="block-data"><strong>Transactions:</strong></div>';
                    block.transactions.forEach((tx, i) => {
                        if (tx.type === 'contract_call') {
                            const success = tx.result && tx.result.success ? 'OK' : 'FAIL';
                            const gasUsed = tx.result ? tx.result.gas_used : 'N/A';
                            transactionDetails += `
                                <div class="block-data" style="margin-left: 10px; font-size: 12px;">
                                    ${i+1}. ${success} Contract: ${tx.call.function}(${JSON.stringify(tx.call.params)}) 
                                    [Gas: ${gasUsed}]
                                </div>
                            `;
                        } else if (tx.type === 'message') {
                            transactionDetails += `
                                <div class="block-data" style="margin-left: 10px; font-size: 12px;">
                                    ${i+1}. Message: "${tx.data}" by ${tx.sender}
                                </div>
                            `;
                        }
                    });
                }
                
                blockDiv.innerHTML = `
                    <div class="block-header">Block #${block.id}</div>
                    <div class="block-data">Summary: ${block.data}</div>
                    <div class="block-data">Hash: ${block.hash}</div>
                    <div class="block-data">Time: ${new Date(block.timestamp).toLocaleTimeString()}</div>
                    ${transactionDetails}
                `;
                blockchainDiv.appendChild(blockDiv);
            });
        }

        function updatePeersList() {
            const peersDiv = document.getElementById('peers-list');
            peersDiv.innerHTML = '';
            
            if (!mesh.dataChannels || mesh.dataChannels.size === 0) {
                peersDiv.innerHTML = '<div>No peers connected</div>';
                return;
            }
            
            mesh.dataChannels.forEach((dc, peerId) => {
                const peerDiv = document.createElement('div');
                peerDiv.className = 'peer';
                peerDiv.textContent = peerId.substring(0, 8);
                peersDiv.appendChild(peerDiv);
            });
        }

        // Event listeners
        document.getElementById('connect-btn').addEventListener('click', async () => {
            if (mesh.connected) {
                mesh.ws.close();
            } else {
                await mesh.connect();
            }
        });

        document.getElementById('join-network-btn').addEventListener('click', () => {
            const networkId = mesh.getSelectedNetwork();
            if (networkId) {
                mesh.joinNetwork(networkId);
            } else {
                log('Please select or enter a network name');
            }
        });

        document.getElementById('refresh-networks-btn').addEventListener('click', () => {
            mesh.refreshNetworkList();
        });

        document.getElementById('discover-btn').addEventListener('click', () => {
            mesh.send({ type: 'peers', peers: [] });
            log('Discovering peers in network...');
        });

        document.getElementById('connect-all-btn').addEventListener('click', () => {
            mesh.connectToAll();
            log('Connecting to all peers in network...');
        });

        document.getElementById('send-btn').addEventListener('click', () => {
            const input = document.getElementById('tx-input');
            const data = input.value.trim();
            if (data) {
                const tx = blockchain.addMessage(data, getUserId());
                
                const txMessage = { type: 'transaction', transaction: tx };
                if (mesh.connected) mesh.send(txMessage);
                mesh.broadcast(txMessage);
                
                log(`Sent message: ${data}`);
                input.value = '';
                updateUI();
            }
        });

        document.getElementById('mine-btn').addEventListener('click', () => {
            const block = blockchain.mineBlock();
            if (block) {
                const blockMessage = { type: 'block', block: block };
                if (mesh.connected) mesh.send(blockMessage);
                mesh.broadcast(blockMessage);
                
                log(`Mined block #${block.id}`);
                updateUI();
                updateOrderBookFromContract();
                
                // Send blockchain update to enterprise after mining
                setTimeout(() => {
                    blockchain.sendBlockchainUpdate();
                }, 100);
            }
        });

        // Close modals when clicking outside
        window.onclick = function(event) {
            const editorModal = document.getElementById('contract-editor-modal');
            const newModal = document.getElementById('new-contract-modal');
            
            if (event.target === editorModal) {
                closeContractEditor();
            }
            if (event.target === newModal) {
                closeNewContractDialog();
            }
        };

        // Initialize  
        document.getElementById('server-input').value = `${window.location.hostname}:3030`;
        updateUI();
        updatePeersList();
        // Initialize order book from smart contract
        setTimeout(() => {
            updateOrderBookFromContract();
        }, 200);
        log('Multi-language blockchain with smart contracts started');
        log('Available runtimes: Rust, Python, WASM, JavaScript');
        log('Contract editor integrated - deploy and test now work with direct blockchain access');
    </script>
</body>
</html>
