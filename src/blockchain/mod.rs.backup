use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[cfg(target_arch = "wasm32")]
use wasm_bindgen::prelude::*;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Block {
    pub height: u64,
    pub hash: String,
    pub previous_hash: String,
    pub timestamp: u64,
    pub validator: String,
    pub transactions: Vec<Transaction>,
    pub stake_weight: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub tx_type: TransactionType,
    pub timestamp: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TransactionType {
    Transfer,
    Stake,
    Trading { asset: String, quantity: u64, price: u64 },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Validator {
    pub address: String,
    pub stake: u64,
    pub active: bool,
}

// Keep existing enterprise types for compatibility
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TenantBlockchainUpdate {
    pub network_id: String,
    pub peer_id: String,
    pub new_blocks: Vec<TenantBlockData>,
    pub timestamp: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TenantBlockData {
    pub block_id: u64,
    pub block_hash: String,
    pub transactions: Vec<String>,
    pub timestamp: u64,
    pub previous_hash: String,
}

#[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
pub struct Blockchain {
    chain: Vec<Block>,
    pending_transactions: Vec<Transaction>,
    validators: HashMap<String, Validator>,
    total_stake: u64,
    // Enterprise-specific fields for dashboard
    tenant_blocks: Vec<TenantBlockData>,
}

#[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
impl Blockchain {
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen(constructor))]
    pub fn new() -> Self {
        let mut blockchain = Self {
            chain: Vec::new(),
            pending_transactions: Vec::new(),
            validators: HashMap::new(),
            total_stake: 0,
            tenant_blocks: Vec::new(),
        };
        blockchain.create_genesis_block();
        blockchain
    }

    fn create_genesis_block(&mut self) {
        let genesis = Block {
            height: 0,
            hash: "0".repeat(64),
            previous_hash: "0".repeat(64),
            timestamp: Self::current_timestamp(),
            validator: "genesis".to_string(),
            transactions: Vec::new(),
            stake_weight: 0,
        };
        self.chain.push(genesis);
    }

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn add_validator(&mut self, address: String, stake: u64) {
        let validator = Validator {
            address: address.clone(),
            stake,
            active: true,
        };
        self.total_stake += stake;
        self.validators.insert(address, validator);
    }

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn add_transaction(&mut self, from: String, to: String, amount: u64) -> String {
        let tx = Transaction {
            id: format!("tx_{}", Self::current_timestamp()),
            from,
            to,
            amount,
            tx_type: TransactionType::Transfer,
            timestamp: Self::current_timestamp(),
        };
        let tx_id = tx.id.clone();
        self.pending_transactions.push(tx);
        tx_id
    }

    // Proof of Stake mining
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn mine_block(&mut self) -> bool {
        if self.pending_transactions.is_empty() {
            return false;
        }

        let validator = self.select_validator();
        if validator.is_none() {
            return false;
        }

        let last_block = self.chain.last().unwrap();
        let validator_addr = validator.unwrap();
        let stake_weight = self.validators.get(&validator_addr).unwrap().stake;

        let block = Block {
            height: last_block.height + 1,
            hash: self.calculate_hash(last_block.height + 1, &last_block.hash, &validator_addr),
            previous_hash: last_block.hash.clone(),
            timestamp: Self::current_timestamp(),
            validator: validator_addr,
            transactions: self.pending_transactions.clone(),
            stake_weight,
        };

        self.chain.push(block);
        self.pending_transactions.clear();
        true
    }

    fn select_validator(&self) -> Option<String> {
        if self.validators.is_empty() {
            return None;
        }

        let seed = Self::current_timestamp() % self.total_stake.max(1);
        let mut cumulative = 0;

        for (address, validator) in &self.validators {
            if validator.active {
                cumulative += validator.stake;
                if seed < cumulative {
                    return Some(address.clone());
                }
            }
        }

        self.validators.iter()
            .find(|(_, v)| v.active)
            .map(|(addr, _)| addr.clone())
    }

    fn calculate_hash(&self, height: u64, previous_hash: &str, validator: &str) -> String {
        use sha2::{Sha256, Digest};
        let input = format!("{}{}{}{}", height, previous_hash, validator, Self::current_timestamp());
        let mut hasher = Sha256::new();
        hasher.update(input.as_bytes());
        hex::encode(hasher.finalize())
    }

    // Enterprise-specific methods for dashboard compatibility
    pub fn add_tenant_blocks(&mut self, update: &TenantBlockchainUpdate) {
        for block in &update.new_blocks {
            self.tenant_blocks.push(block.clone());
        }
        
        if self.tenant_blocks.len() > 100 {
            let start_idx = self.tenant_blocks.len() - 100;
            self.tenant_blocks = self.tenant_blocks[start_idx..].to_vec();
        }
    }

    pub fn get_recent_tenant_blocks(&self, limit: usize) -> Vec<serde_json::Value> {
        let start_idx = if self.tenant_blocks.len() > limit {
            self.tenant_blocks.len() - limit
        } else {
            0
        };

        self.tenant_blocks[start_idx..].iter().map(|block| {
            serde_json::json!({
                "network_id": "tenant_network",
                "block_id": block.block_id,
                "block_hash": block.block_hash,
                "transactions": block.transactions,
                "timestamp": block.timestamp,
                "previous_hash": block.previous_hash
            })
        }).collect()
    }

    pub fn get_tenant_summaries(&self) -> Vec<serde_json::Value> {
        vec![serde_json::json!({
            "tenant_id": "default_network",
            "block_count": self.tenant_blocks.len(),
            "transaction_count": self.tenant_blocks.iter().map(|b| b.transactions.len()).sum::<usize>(),
            "last_activity": self.tenant_blocks.last().map(|b| b.timestamp).unwrap_or(0)
        })]
    }

    // WASM-compatible getters
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn get_chain_length(&self) -> u64 {
        self.chain.len() as u64
    }

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn get_pending_count(&self) -> u64 {
        self.pending_transactions.len() as u64
    }

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn get_validator_count(&self) -> u64 {
        self.validators.len() as u64
    }

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn get_latest_block_json(&self) -> String {
        match self.chain.last() {
            Some(block) => serde_json::to_string(block).unwrap_or_default(),
            None => "{}".to_string(),
        }
    }

    fn current_timestamp() -> u64 {
        #[cfg(target_arch = "wasm32")]
        {
            (js_sys::Date::now() / 1000.0) as u64
        }
        #[cfg(not(target_arch = "wasm32"))]
        {
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs()
        }
    }

    // Native-only methods
    #[cfg(not(target_arch = "wasm32"))]
    pub fn add_block(&mut self, block: Block) -> bool {
        if self.validate_block(&block) {
            self.chain.push(block);
            true
        } else {
            false
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn validate_block(&self, block: &Block) -> bool {
        if let Some(last_block) = self.chain.last() {
            block.height == last_block.height + 1 && 
            block.previous_hash == last_block.hash &&
            self.validators.contains_key(&block.validator)
        } else {
            false
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub fn get_blocks(&self) -> &Vec<Block> {
        &self.chain
    }
}

// Trading OrderBook
#[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
pub struct OrderBook {
    bids: Vec<Order>,
    asks: Vec<Order>,
    trades: Vec<Trade>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Order {
    pub id: String,
    pub trader: String,
    pub asset: String,
    pub quantity: u64,
    pub price: u64,
    pub side: OrderSide,
    pub timestamp: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderSide {
    Buy,
    Sell,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Trade {
    pub id: String,
    pub asset: String,
    pub quantity: u64,
    pub price: u64,
    pub buyer: String,
    pub seller: String,
    pub timestamp: u64,
}

#[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
impl OrderBook {
    #[cfg_attr(target_arch = "wasm32", wasm_bindgen(constructor))]
    pub fn new() -> Self {
        Self {
            bids: Vec::new(),
            asks: Vec::new(),
            trades: Vec::new(),
        }
    }

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn place_buy_order(&mut self, trader: String, asset: String, quantity: u64, price: u64) -> String {
        let order = Order {
            id: format!("buy_{}", self.current_timestamp()),
            trader,
            asset,
            quantity,
            price,
            side: OrderSide::Buy,
            timestamp: self.current_timestamp(),
        };
        let order_id = order.id.clone();
        self.match_order(order);
        order_id
    }

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn place_sell_order(&mut self, trader: String, asset: String, quantity: u64, price: u64) -> String {
        let order = Order {
            id: format!("sell_{}", self.current_timestamp()),
            trader,
            asset,
            quantity,
            price,
            side: OrderSide::Sell,
            timestamp: self.current_timestamp(),
        };
        let order_id = order.id.clone();
        self.match_order(order);
        order_id
    }

    fn match_order(&mut self, mut order: Order) {
        // Get timestamp first, before any borrows
        let current_time = self.current_timestamp();
        
        let opposite_orders = match order.side {
            OrderSide::Buy => &mut self.asks,
            OrderSide::Sell => &mut self.bids,
        };

        let mut to_remove = Vec::new();
        
        for (i, existing_order) in opposite_orders.iter_mut().enumerate() {
            if existing_order.asset != order.asset {
                continue;
            }

            let can_trade = match order.side {
                OrderSide::Buy => order.price >= existing_order.price,
                OrderSide::Sell => order.price <= existing_order.price,
            };

            if can_trade {
                let trade_quantity = order.quantity.min(existing_order.quantity);
                let trade_price = existing_order.price;

                let trade = Trade {
                    id: format!("trade_{}", current_time),  // Use pre-calculated timestamp
                    asset: order.asset.clone(),
                    quantity: trade_quantity,
                    price: trade_price,
                    buyer: match order.side {
                        OrderSide::Buy => order.trader.clone(),
                        OrderSide::Sell => existing_order.trader.clone(),
                    },
                    seller: match order.side {
                        OrderSide::Sell => order.trader.clone(),
                        OrderSide::Buy => existing_order.trader.clone(),
                    },
                    timestamp: current_time,  // Use pre-calculated timestamp
                };

                self.trades.push(trade);
                
                order.quantity -= trade_quantity;
                existing_order.quantity -= trade_quantity;

                if existing_order.quantity == 0 {
                    to_remove.push(i);
                }

                if order.quantity == 0 {
                    break;
                }
            }
        }

        for &index in to_remove.iter().rev() {
            opposite_orders.remove(index);
        }

        if order.quantity > 0 {
            match order.side {
                OrderSide::Buy => {
                    self.bids.push(order);
                    self.bids.sort_by(|a, b| b.price.cmp(&a.price));
                }
                OrderSide::Sell => {
                    self.asks.push(order);
                    self.asks.sort_by(|a, b| a.price.cmp(&b.price));
                }
            }
        }
    }

//

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn get_order_book_json(&self) -> String {
        let data = serde_json::json!({
            "bids": self.bids,
            "asks": self.asks
        });
        serde_json::to_string(&data).unwrap_or_default()
    }

    #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
    pub fn get_recent_trades_json(&self) -> String {
        let recent_trades: Vec<&Trade> = self.trades.iter().rev().take(20).collect();
        serde_json::to_string(&recent_trades).unwrap_or_default()
    }

    fn current_timestamp(&self) -> u64 {
        #[cfg(target_arch = "wasm32")]
        {
            (js_sys::Date::now() / 1000.0) as u64
        }
        #[cfg(not(target_arch = "wasm32"))]
        {
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs()
        }
    }
}
